"use strict";var e=require("@nlux/core");const t=e=>{const t=/\/.*\/(invoke|stream)$/g.exec(e);if(!t||t.length<2)return;const r=t[1];return"invoke"===r||"stream"===r?r:void 0},r=r=>{const s=t(r.url),o=r.dataTransferMode,a=s?"stream"===s?"stream":"fetch":void 0;const i=a??r.dataTransferMode??n.defaultDataTransferMode;return o&&a&&o!==a&&e.warnOnce(`The data transfer mode provided to LangServe adapter does not match the LangServe runnable URL action. When you provide a runnable URL that ends with '/${s}', the data transfer mode is automatically set to '${a}' and the 'dataTransferMode' option should not be provided or should be set to '${a}'`),i},s=e=>{const t=e.url;return/\/.*\/(invoke|stream)$/g.test(t)?t.replace(/\/(invoke|stream)$/g,""):t},o=e=>{const o=s(e).replace(/\/$/,""),n=(e=>{const s=e.url,o=t(s);return o||("fetch"===r(e)?"invoke":"stream")})(e);return`${o}/${n}`};class n{constructor(t){this.__instanceId=`${this.info.id}-${e.uid()}`,this.__options={...t},this.theDataTransferModeToUse=r(t),this.theHeadersToUse=t.headers||{},this.theUseInputSchemaOptionToUse="boolean"!=typeof t.useInputSchema||t.useInputSchema,this.theEndpointUrlToUse=o(t),this.theRunnableNameToUse=(e=>s(e).replace(/\/$/,"").split("/").pop()||"langserve-runnable")(t),this.theInputSchemaUrlToUse=((e,t)=>{const r=s(e).replace(/\/$/,"");return"input"===t?`${r}/input_schema`:`${r}/output_schema`})(t,"input"),this.init()}get dataTransferMode(){return this.theDataTransferModeToUse}get endpointUrl(){return this.theEndpointUrlToUse}get headers(){return this.theHeadersToUse}get id(){return this.__instanceId}get info(){return{id:"langserve-adapter",capabilities:{chat:!0,fileUpload:!1,textToSpeech:!1,speechToText:!1}}}get inputPreProcessor(){return this.__options.inputPreProcessor}get inputSchema(){return this.theInputSchemaToUse}get outputPreProcessor(){return this.__options.outputPreProcessor}get runnableName(){return this.theRunnableNameToUse}get useInputSchema(){return this.theUseInputSchemaOptionToUse}get inputSchemaUrl(){return this.theInputSchemaUrlToUse}async fetchSchema(t){try{const r=await fetch(t),s=await r.json();return"object"==typeof s&&s?s:void e.warn(`LangServe adapter is unable process schema loaded from: ${t}`)}catch(r){return void e.warn(`LangServe adapter is unable to fetch schema from: ${t}`)}}init(){!this.inputPreProcessor&&this.useInputSchema&&this.fetchSchema(this.inputSchemaUrl).then((e=>{this.theInputSchemaToUse=e}))}getDisplayableMessageFromAiOutput(t){if(this.outputPreProcessor)return this.outputPreProcessor(t);if("string"==typeof t)return t;const r=t;if("object"==typeof r&&r&&"string"==typeof r.content)return r.content;e.warn(`LangServe adapter is unable to process output returned from the endpoint:\n ${JSON.stringify(t)}`)}getRequestBody(t,r){if(this.inputPreProcessor){const e=this.inputPreProcessor(t,r);return JSON.stringify({input:e})}if(this.inputSchema){const r=((t,r,s,o)=>{if(!s||"object"!=typeof s.properties)return t;if("object"!=typeof s||!s)return e.warn(`LangServer adapter cannot process the input schema fetched for runnable "${o}". The user message will be sent to LangServe endpoint as is without transformations. To override this behavior, you can either set the "useInputSchema" option to false, or provide a custom input pre-processor via the "inputPreProcessor" option, or update your endpoint and input schema to have an object with a single string property or a string as input.`),t;if("string"===s.type)return t;if("object"===s.type){const r="object"==typeof s.properties&&s.properties?s.properties:{},o=Object.keys(r).filter((e=>e&&"string"==typeof s.properties[e].type)).map((e=>e));if(1===o.length)return{[o[0]]:t};e.warn('LangServer adapter cannot find a valid property to match to user input inside the "${runnableName}" input schema. The user message will be sent to LangServe endpoint as is without transformations. To override this behavior, you can either set the "useInputSchema" option to false, or provide a custom input pre-processor via the "inputPreProcessor" option, or update your endpoint and input schema to have an object with a single string property or a string accepted as part of input schema.')}})(t,0,this.inputSchema,this.runnableName);if(void 0!==r)return JSON.stringify({input:r})}return JSON.stringify({input:t})}}n.defaultDataTransferMode="stream";class a extends n{constructor(e){super(e)}async fetchText(e,t){const r=this.getRequestBody(e,t.conversationHistory),s=await fetch(this.endpointUrl,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:r});if(!s.ok)throw new Error(`LangServe runnable returned status code: ${s.status}`);const o=await s.json();if("object"!=typeof o||!o||void 0===o.output)throw new Error('Invalid response from LangServe runnable: Response is not an object or does not contain an "output" property');const n="object"==typeof o&&o?o.output:void 0;return this.getDisplayableMessageFromAiOutput(n)??""}streamText(t,r,s){throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot stream text from the fetch adapter!"})}}const i=t=>{const r=/^event:\s+(?<event>[\w]+)((\r?)\n(\r?)data: (?<data>(.|\n)*))?/gm.exec(t);if(!r)return;const{event:s,data:o}=r.groups||{};if(s&&("data"===s||"end"===s))try{return{event:s,data:o?JSON.parse(o):void 0}}catch(t){return e.warn(`LangServe stream adapter failed to parse data for chunk event "${s}" | Data: ${o}`),{event:s,data:void 0}}},h=e=>{if(!e)return[];const t=/(((?<=^)|(?<=\n))event:\s+(\w+))/g,r=[];let s=t.exec(e);for(;s;)r.push(s.index),s=t.exec(e);const o=(t,s)=>{const o=r[s+1]||e.length;return e.substring(t,o)};try{return r.map(o).map(i).filter((e=>void 0!==e)).map((e=>e))}catch(e){return e instanceof Error?e:[]}},u=e=>"object"==typeof e&&null!==e&&e.message?.toLowerCase().includes("connection error")?"NX-NT-001":null;class c extends n{constructor(e){super(e)}async fetchText(t,r){throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot fetch text using the stream adapter!"})}streamText(t,r,s){const o=this.getRequestBody(t,s.conversationHistory);fetch(this.endpointUrl,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:o}).then((async t=>{if(!t.ok)throw new e.NluxError({source:this.constructor.name,message:`LangServe runnable returned status code: ${t.status}`});if(!t.body)throw new e.NluxError({source:this.constructor.name,message:`LangServe runnable returned status code: ${t.status}`});const s=t.body.getReader(),o=new TextDecoder;let n=!1;for(;!n;){const{value:t,done:a}=await s.read();if(a){n=!0;continue}const i=o.decode(t),u=h(i);if(Array.isArray(u))for(const e of u){if("data"===e.event&&void 0!==e.data){const t=this.getDisplayableMessageFromAiOutput(e.data);"string"==typeof t&&t&&r.next(t)}if("end"===e.event){r.complete(),n=!0;break}}u instanceof Error&&(e.warn(u),r.error(u),n=!0)}})).catch((t=>{e.warn(t),r.error(new e.NluxUsageError({source:this.constructor.name,message:t.message,exceptionId:u(t)??void 0}))}))}}class p{constructor(e){e&&(this.theDataTransferMode=e.theDataTransferMode,this.theHeaders=e.theHeaders,this.theInputPreProcessor=e.theInputPreProcessor,this.theOutputPreProcessor=e.theOutputPreProcessor,this.theUrl=e.theUrl)}create(){if(!this.theUrl)throw new e.NluxUsageError({source:this.constructor.name,message:"Unable to create LangServe adapter. URL is missing. Make sure you are calling withUrl() before calling create()."});const t={url:this.theUrl,dataTransferMode:this.theDataTransferMode,headers:this.theHeaders,inputPreProcessor:this.theInputPreProcessor,outputPreProcessor:this.theOutputPreProcessor,useInputSchema:this.theUseInputSchema};return"stream"===r(t)?new c(t):new a(t)}withDataTransferMode(t){if(void 0!==this.theDataTransferMode)throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot set the data loading mode more than once"});return this.theDataTransferMode=t,this}withHeaders(t){if(void 0!==this.theHeaders)throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot set the headers option more than once"});return this.theHeaders=t,this}withInputPreProcessor(t){if(void 0!==this.theInputPreProcessor)throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot set the input pre-processor option more than once"});return this.theInputPreProcessor=t,this}withInputSchema(t){if(void 0!==this.theUseInputSchema)throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot set the input schema option more than once"});return this.theUseInputSchema=t,this}withOutputPreProcessor(t){if(void 0!==this.theOutputPreProcessor)throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot set the output pre-processor option more than once"});return this.theOutputPreProcessor=t,this}withUrl(t){if(void 0!==this.theUrl)throw new e.NluxUsageError({source:this.constructor.name,message:"Cannot set the runnable URL option more than once"});return this.theUrl=t,this}}Object.defineProperty(exports,"debug",{enumerable:!0,get:function(){return e.debug}}),exports.createChatAdapter=()=>new p;
