import React, { useEffect, JSX, FunctionComponent, ComponentClass, ReactNode, Context } from 'react';
import { ChatAdapter, ChatAdapterBuilder, EventsMap, ConversationItem, HighlighterExtension, ConversationOptions, LayoutOptions, PromptBoxOptions, ContextItems, AiContext as AiContext$1, ContextItemDataType, ContextAdapter, ContextAdapterBuilder } from '@nlux/core';
export { ChatAdapter, ChatAdapterBuilder, ChatAdapterExtras, ConversationOptions, DataTransferMode, ErrorCallback, ErrorEventDetails, EventCallback, EventName, EventsMap, ExceptionId, HighlighterExtension, LayoutOptions, MessageReceivedCallback, MessageSentCallback, NluxConfigError, NluxError, NluxRenderingError, NluxUsageError, NluxValidationError, PreDestroyCallback, PreDestroyEventDetails, PromptBoxOptions, ReadyCallback, ReadyEventDetails, StandardChatAdapter, StreamingAdapterObserver, debug } from '@nlux/core';

type UseEffectParams = Parameters<typeof useEffect>;
type EffectCallback = UseEffectParams[0];
type DependencyList = UseEffectParams[1];
type UseEffectReturn = ReturnType<typeof useEffect>;
declare function useDeepCompareEffect$1(callback: EffectCallback, dependencies: DependencyList): UseEffectReturn;

interface BotPersona {
    name: string;
    picture: string | JSX.Element;
    tagline?: string;
}
interface UserPersona {
    name: string;
    picture: string | JSX.Element;
}
interface PersonaOptions {
    bot?: BotPersona;
    user?: UserPersona;
}

/**
 * Properties for the AiChat React component.
 */
type AiChatComponentProps = {
    /**
     * The adapter or adapter builder to use for the conversation.
     * This can be obtained via useChatAdapter() hook for standard adapters or by creating your own custom adapter
     * that implements `ChatAdapter` or `ChatAdapterBuilder` interfaces.
     */
    adapter: ChatAdapter | ChatAdapterBuilder;
    /**
     * Event listeners to be attached to chat room events.
     */
    events?: Partial<EventsMap>;
    /**
     * CSS class name to be applied to the root element.
     */
    className?: string;
    /**
     * The initial conversation to display when the AiChat component is mounted.
     * This property is not reactive, which means that its value is only read once when the
     * component is mounted and any subsequent changes to it will be ignored.
     */
    initialConversation?: ConversationItem[];
    /**
     * The syntax highlighter to use for any source code generated by the LLM
     * and displayed in the conversation.
     */
    syntaxHighlighter?: HighlighterExtension;
    /**
     * The options to use for the conversation.
     */
    conversationOptions?: ConversationOptions;
    /**
     * The options to use for the layout.
     */
    layoutOptions?: LayoutOptions;
    /**
     * The options to use for the prompt box.
     */
    promptBoxOptions?: PromptBoxOptions;
    /**
     * The options to use for the personaOptions.
     */
    personaOptions?: PersonaOptions;
};

declare const AiChat: (props: Readonly<AiChatComponentProps>) => React.JSX.Element;

type AiContextProviderProps = {
    initialItems?: ContextItems;
    errorComponent?: FunctionComponent<{
        error?: string;
    }> | ComponentClass<{
        error?: string;
    }>;
    loadingComponent?: FunctionComponent | ComponentClass;
    children: ReactNode;
};
/**
 * An object that represents the AI context.
 * This object is created as a result of calling createAiContext().
 *
 * The Provider property is a React component that provides the AI context to the children.
 * To be used as <aiContextInstance.Provider> context aware app .. </aiContextInstance.Provider>
 *
 * The ref property is a React context that can be used to access the React context value.
 * Do not use the ref property directly, the useAiContext() and useAiTask() hooks should be used instead.
 */
type AiContext = {
    Provider: (props: AiContextProviderProps) => ReactNode;
    ref: Context<AiContext$1>;
};

type UpdateContextItem = (itemValue: ContextItemDataType) => void;
type DiscardContextItem = () => void;
/**
 * Use this hook to sync parts of the component state with the AI context.
 * It will create a new AI context item and will keep it in sync with the AI context.
 * When the state item changes, the itemValue will should be kept up to date.
 * When the component is unmounted, the context item will be discarded.
 *
 * @param {AiContext} aiContext The AI context instance to use, created with createAiContext()
 * @param {string} itemDescription The description of the item. This will be used by LLMs to understand context
 * @param {ContextItemDataType} itemValue The item value to be synced. Changing this value will update the AI context.
 *
 * Usage example:
 *
 * ```tsx
 * const MyComponent = () => {
 *    const [myStateItem, setMyStateItem] = useState('initial value');
 *    useAiContext(MyAiContext, 'Detailed description of my state item', myStateItem);
 *    return <div>...</div>;
 * };
 */
declare const useAiContext: (aiContext: AiContext, itemDescription: string, itemValue: ContextItemDataType) => void;

/**
 * Use this hook to register a new task that can be trigger by the AI during <AiChat /> conversations.
 * It will create a new AI context task and will keep it in sync with the AI context.
 * The description is used by LLMs to understand the purpose of the task.
 * The callback is the function that will be called when the task is triggered.
 * The parametersDescription is used by LLMs to determine the value of each parameter to be passed to the task.
 *
 * @param {AiContext} aiContext The AI context instance to use, created with createAiContext()
 * @param {string} taskDescription The description of the task. This will be used by LLMs to understand context.
 * @param {Function} callback The function to be called when the task is triggered.
 * @param {string[]} parametersDescription An array of descriptions for each parameter of the task.
 *
 * Usage example:
 *
 * ```tsx
 * const MyComponent = () => {
 *   const taskCallback = useCallback((param1, param2) => {
 *     // Do something with the parameters
 *   }, []);
 *
 *   useAiTask(
 *      MyAiContext, 'Description of the task',
 *      taskCallback, ['Description of the first parameter', 'Description of the second parameter']
 *    );
 *
 *   return <div>...</div>;
 * };
 * ```
 */
declare const useAiTask: (aiContext: AiContext, taskDescription: string, callback: Function, parametersDescription?: string[]) => void;

/**
 * Creates a new AI context with a React context provider that can be used to sync application state
 * with the backend for AI processing.
 *
 * The input is a context adapter that handles the communication with the backend. nlux provides several
 * context adapters out of the box, but developers can also create their own adapters by implementing the
 * ContextAdapter interface.
 *
 * Usage:
 *
 * At the root level of the application, create the AI context and wrap the app with the context provider:
 * ```tsx
 * const MyAiContext = createAiContext(contextAdapter);
 *
 * const App = () => (
 *   <MyAiContext.Provider>
 *     <MyApp/>
 *   </MyAiContext.Provider>
 * );
 * ```
 *
 * Then, in any component that needs to access the AI context, use the context reference:
 *
 * ```tsx
 * useAiContext(MyAiContext, 'Description of the data', dataToSync);
 * useAiTask(MyAiContext, 'Description of the task', callbackFunction, ['Description of the parameters']);
 * ```
 *
 * @param {ContextAdapter | ContextAdapterBuilder} adapter
 * @returns {AiContext}
 */
declare const createAiContext: (adapter: ContextAdapter | ContextAdapterBuilder) => AiContext;

declare const useDeepCompareEffect: typeof useDeepCompareEffect$1;

export { AiChat, type AiChatComponentProps, type AiContext, type AiContextProviderProps, type BotPersona, type DiscardContextItem, type PersonaOptions, type UpdateContextItem, type UserPersona, createAiContext, useAiContext, useAiTask, useDeepCompareEffect };
