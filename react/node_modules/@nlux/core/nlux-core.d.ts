type Highlighter = (input: string, language: string) => string;
type HighlighterColorMode = 'dark' | 'light';
type CreateHighlighterOptions = {
    language?: string;
    colorMode?: HighlighterColorMode;
};
interface HighlighterExtension {
    createHighlighter(options?: CreateHighlighterOptions): Highlighter;
    highlightingClass(language?: string): string;
}

type HistoryPayloadSize = number | 'none' | 'max';
interface ConversationOptions {
    /**
     * Indicates the number of messages from conversation history that should be sent to the backend with each message.
     * For custom adapters, the history will be available as part of `extras.conversationHistory` attribute.
     * For standard adapters, the history will be automatically handled by the adapter.
     *
     * By default, the entire conversation history is sent with each message.
     * Set to `null` to disable sending conversation history with each message.
     * Or set to a positive integer to send a specific number of messages.
     *
     * @default 'max'
     */
    historyPayloadSize?: HistoryPayloadSize;
    /**
     * Indicates whether rendered links should open in a new window.
     *
     * @default false
     */
    openLinksInNewWindow?: boolean;
    /**
     * Indicates whether the conversation should be scrolled to the bottom when a new message is added.
     *
     * @default true
     */
    scrollWhenGenerating?: boolean;
    /**
     * The interval in milliseconds at which new characters are added to the conversation when a message
     * is being generated and rendering in the UI.
     * Set to `null` to disable the streaming animation.
     *
     * @default 10
     */
    streamingAnimationSpeed?: number | null;
}

type LayoutOptions = {
    /**
     * The maximum height of the chat component. This can be a number or a string with a unit (e.g. '100px').
     * @default '400px'
     */
    maxHeight?: number | string;
    /**
     * The maximum width of the chat component. This can be a number or a string with a unit (e.g. '100px').
     * @default '400px'
     */
    maxWidth?: number | string;
    /**
     * The height of the chat component. This can be a number or a string with a unit (e.g. '100px').
     */
    height?: number | string;
    /**
     * The width of the chat component. This can be a number or a string with a unit (e.g. '100px').
     */
    width?: number | string;
};

interface BotPersona {
    name: string;
    picture: string | Readonly<HTMLElement>;
    tagline?: string;
}
interface UserPersona {
    name: string;
    picture: string | Readonly<HTMLElement>;
}
interface PersonaOptions {
    bot?: BotPersona;
    user?: UserPersona;
}

interface PromptBoxOptions {
    /**
     * Indicates whether the prompt input field should be focused when the prompt is shown.
     * @default false
     */
    autoFocus?: boolean;
    /**
     * The placeholder text to show in the prompt input field when it's empty.
     * @default ''
     */
    placeholder?: string;
}

type OutputFormat = 'text' | 'audio' | 'markdown' | 'html' | 'image' | 'video' | 'file';
type InputFormat = 'text';
type AdapterEncodeFunction<OutboundPayload> = (input: string) => Promise<OutboundPayload>;
type AdapterDecodeFunction<InboundPayload> = (output: InboundPayload) => Promise<string | undefined>;
/**
 * This type represents the information that the AiChat needs to know about an adapter.
 * It is used to determine which adapters are available and what capabilities they have.
 */
type StandardAdapterInfo = Readonly<{
    id: string;
    capabilities: Readonly<{
        chat: boolean;
        fileUpload: boolean;
        textToSpeech: boolean;
        speechToText: boolean;
    }>;
}>;

/**
 * This interface is used by standard adapters provided by nlux to communicate with the AiChat component.
 */
interface StandardChatAdapter {
    get dataTransferMode(): 'stream' | 'fetch';
    fetchText(message: string, extras: ChatAdapterExtras): Promise<string>;
    get id(): string;
    get info(): StandardAdapterInfo;
    streamText(message: string, observer: StreamingAdapterObserver, extras: ChatAdapterExtras): void;
}

/**
 * The role of a participant in a conversation.
 *
 * The 'ai' role is used to represent the AI model responding to the user.
 * The 'system' role is used to represent the system sending messages to the bot to control its behavior.
 * The 'user' role is used to represent the user sending messages to the bot.
 */
type ParticipantRole = 'user' | 'system' | 'ai';

type ConversationItem = {
    role: ParticipantRole;
    message: string;
};

declare const AllExceptions: {
    'NX-AD-001': {
        type: string;
        message: string;
    };
    'NX-NT-001': {
        type: string;
        message: string;
    };
    'NX-NT-002': {
        type: string;
        message: string;
    };
    'NX-NT-003': {
        type: string;
        message: string;
    };
    'NX-NT-004': {
        type: string;
        message: string;
    };
};
type ExceptionId = keyof typeof AllExceptions;

type ErrorEventDetails = {
    errorId: ExceptionId;
    message: string;
};
type ReadyEventDetails = {
    aiChatProps: AiChatProps;
};
type PreDestroyEventDetails = {
    aiChatProps: AiChatProps;
    conversationHistory: Readonly<ConversationItem[]>;
};
/**
 * The callback for when an error event is emitted.
 *
 * @param errorDetails The details of the error event such as the error message and the error id.
 */
type ErrorCallback = (errorDetails: ErrorEventDetails) => void;
/**
 * The callback for when a message is received.
 * This is called when the chat component receives the full response from the adapter.
 *
 * @param message The message that was received.
 */
type MessageReceivedCallback = (message: string) => void;
/**
 * The callback for when a message is sent.
 * This is called when the chat component sends the message to the adapter.
 *
 * @param message The message that was sent.
 */
type MessageSentCallback = (message: string) => void;
/**
 * The callback for when the chat component is ready.
 * This is called when the chat component is fully initialized and ready to be used.
 *
 * @param readyDetails The details of the ready event such as the AiChatProps used to initialize the chat component.
 */
type ReadyCallback = (readyDetails: ReadyEventDetails) => void;
/**
 * The callback for when the chat component is about to be destroyed.
 * This is called when the chat component is about to be destroyed and unmounted from the DOM.
 *
 * @param preDestroyDetails The details of the pre-destroy event such as the AiChatProps used to initialize the chat
 * component and the conversation history.
 */
type PreDestroyCallback = (preDestroyDetails: PreDestroyEventDetails) => void;
type EventsMap = {
    ready: ReadyCallback;
    preDestroy: PreDestroyCallback;
    messageSent: MessageSentCallback;
    messageReceived: MessageReceivedCallback;
    error: ErrorCallback;
};
type EventName = keyof EventsMap;
type EventCallback = EventsMap[EventName];

/**
 * These are the props that are used internally by the AiChat component.
 */
type AiChatInternalProps = {
    adapter: ChatAdapter | StandardChatAdapter;
    events?: Partial<EventsMap>;
    themeId?: string;
    className?: string;
    initialConversation?: ConversationItem[];
    promptBoxOptions: PromptBoxOptions;
    conversationOptions: ConversationOptions;
    personaOptions: PersonaOptions;
    layoutOptions: LayoutOptions;
    syntaxHighlighter?: HighlighterExtension;
};
/**
 * These are the props that are exposed to the user of the AiChat component.
 * They can be updated using the `updateProps` method, and they are provided to certain adapter methods
 * as part of the `ChatAdapterExtras` attribute.
 *
 * It excludes properties that are used for initialization such as `initialConversation`.
 */
type AiChatProps = Readonly<{
    adapter: ChatAdapter | StandardChatAdapter;
    events?: Partial<EventsMap>;
    themeId?: string;
    className?: string;
    promptBoxOptions?: Readonly<PromptBoxOptions>;
    conversationOptions?: Readonly<ConversationOptions>;
    personaOptions?: Readonly<PersonaOptions>;
    layoutOptions?: Readonly<LayoutOptions>;
    syntaxHighlighter?: HighlighterExtension;
}>;

/**
 * Additional data sent to the adapter when a message is sent.
 */
type ChatAdapterExtras = {
    /**
     * This attribute contains the properties used with the AiChat component.
     */
    aiChatProps: AiChatProps;
    /**
     * This attribute contains the conversation history.
     * It's only included if the `conversationOptions.historyPayloadSize` is set to a positive number or 'all'.
     */
    conversationHistory?: Readonly<ConversationItem[]>;
    /**
     * This attribute contains the unique identifier of the context instance.
     * It's only included if a context instance is used with the AiChat component.
     * This can be used to send the context ID to the API and get a response that is specific to the context instance.
     */
    contextId?: string;
    /**
     * This contains the headers that implementers can use to send additional data such as authentication headers.
     */
    headers?: Record<string, string>;
};

/**
 * This type is used to indicate the mode in which the adapter should request data from the API.
 */
type DataTransferMode = 'stream' | 'fetch';
/**
 * This interface exposes methods that should be implemented by any chat adapter to connect the AiChat component
 * to any API or AI backend. Chat adapters can be used to request data from the API in fetch mode or stream mode.
 *
 * The difference between this and the `AssistAdapter` interface is that this adapter can only return a text response
 * to be displayed to the user. It cannot return a task to be executed by the client. If you are using the `AiChat`
 * component in co-pilot mode, you should use the `AssistAdapter` interface instead.
 */
interface ChatAdapter {
    /**
     * This method should be implemented by any adapter that wants to request data from the API in fetch mode.
     * It should return a promise that resolves to the response from the API.
     * Either this method or `streamText` (or both) should be implemented by any adapter.
     *
     * @param `string` message
     * @param `ChatAdapterExtras` extras
     * @returns Promise<string>
     */
    fetchText?: (message: string, extras: ChatAdapterExtras) => Promise<string>;
    /**
     * This method should be implemented by any adapter to be used with nlux.
     * Either this method or `fetchText` (or both) should be implemented by any adapter.
     *
     * @param {string} message
     * @param {StreamingAdapterObserver} observer
     * @param {ChatAdapterExtras} extras
     */
    streamText?: (message: string, observer: StreamingAdapterObserver, extras: ChatAdapterExtras) => void;
}
/**
 * This interface is used to capture the stream of data being generated by the API and send it to the AiChat
 * user interface as it's being generated.
 */
interface StreamingAdapterObserver {
    /**
     * This method should be called by the adapter when it has completed sending data to the AiChat user interface.
     * This will result in the AiChat component removing the loading indicator and resetting the conversation
     * text input.
     */
    complete(): void;
    /**
     * This method should be called by the adapter when it has an error to send to the AiChat user interface.
     * This will result in the AiChat component displaying an error message to the user, resetting the
     * conversation text input, removing the loading indicator, removing the message sent from the conversation.
     *
     * The error will be logged to the console, but it will not be displayed to the user. A generic error message
     * will be displayed to the user instead.
     *
     * @param {Error} error
     */
    error(error: Error): void;
    /**
     * This method should be called by the adapter when it has new data to send to the AiChat user interface.
     * @param {string} message
     */
    next(message: string): void;
}

/**
 * The base interface for creating a new instance of a StandardChatAdapter.
 * Adapter builders can extend this interface to add additional methods for configuration.
 */
interface ChatAdapterBuilder {
    create(): StandardChatAdapter;
}

/**
 * The main interface representing AiChat component.
 * It provides methods to instantiate, mount, and unmount the component, and listen to its events.
 */
interface IAiChat {
    /**
     * Hides the chat component.
     * This does not unmount the component. It will only hide the chat component from the view.
     */
    hide(): void;
    /**
     * Mounts the chat component to the given root element.
     *
     * @param {HTMLElement} rootElement
     */
    mount(rootElement: HTMLElement): void;
    /**
     * Returns true if the chat component is mounted.
     */
    get mounted(): boolean;
    /**
     * Adds an event listener to the chat component.
     * The callback will be called when the event is emitted, with the expected event details.
     *
     * @param {EventName} event The name of the event to listen to.
     * @param {EventsMap[EventName]} callback The callback to be called, that should match the event type.
     * @returns {IAiChat}
     */
    on(event: EventName, callback: EventsMap[EventName]): IAiChat;
    /**
     * Removes all event listeners from the chat component.
     * When a valid event name is provided, it will remove all listeners for that event.
     * Otherwise, it will remove all listeners for all events.
     *
     * @param {EventName} event
     */
    removeAllEventListeners(event?: EventName): void;
    /**
     * Removes the given event listener for the specified event.
     *
     * @param {EventName} event The name of the event to remove the listener from.
     * @param {EventsMap[EventName]} callback The callback to be removed.
     */
    removeEventListener(event: EventName, callback: EventCallback): void;
    /**
     * Shows the chat component.
     * This method expects the chat component to be mounted.
     */
    show(): void;
    /**
     * Unmounts the chat component.
     * This will remove the chat component from the view and clean up its resources.
     * After unmounting, the chat component can be mounted again.
     */
    unmount(): void;
    /**
     * Updates the properties of the chat component. This method expects the chat component to be mounted.
     * The properties will be updated and the relevant parts of the chat component will be re-rendered.
     *
     * @param {Partial<AiChatProps>} props The properties to be updated.
     */
    updateProps(props: Partial<AiChatProps>): void;
    /**
     * Enabled providing an adapter to the chat component.
     * The adapter will be used to send and receive messages from the chat backend.
     * This method should be called before mounting the chat component, and it should be called only once.
     *
     * @param {ChatAdapterBuilder} adapterBuilder The builder for the chat adapter.
     **/
    withAdapter(adapterBuilder: ChatAdapterBuilder): IAiChat;
    /**
     * Enables providing a class name to the chat component.
     * The class name will be added to the root element of the chat component.
     * This method should be called before mounting the chat component, and it should be called only once.
     *
     * @param {string} className The class name to be added to the chat component.
     */
    withClassName(className: string): IAiChat;
    /**
     * Enables providing conversation options to the chat component.
     * The conversation options will be used to configure the conversation behavior.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {ConversationOptions} conversationOptions The conversation options to be used.
     */
    withConversationOptions(conversationOptions: ConversationOptions): IAiChat;
    /**
     * Enables providing an initial conversation to the chat component.
     * The initial conversation will be used to populate the chat component with a conversation history.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {ConversationItem[]} initialConversation
     * @returns {IAiChat}
     */
    withInitialConversation(initialConversation: ConversationItem[]): IAiChat;
    /**
     * Enables providing layout options to the chat component. The layout options will be used to configure the
     * layout of the chat component. When no layout options are provided, the default layout options will be used.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {LayoutOptions} layoutOptions The layout options to be used.
     */
    withLayoutOptions(layoutOptions: LayoutOptions): IAiChat;
    /**
     * Enables providing persona options to the chat component. The persona options will be used to configure
     * the bot and user personas in the chat component.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {PersonaOptions} personaOptions The persona options to be used.
     */
    withPersonaOptions(personaOptions: PersonaOptions): IAiChat;
    /**
     * Enables providing prompt box options to the chat component.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {PromptBoxOptions} promptBoxOptions The prompt box options to be used.
     */
    withPromptBoxOptions(promptBoxOptions: PromptBoxOptions): IAiChat;
    /**
     * Enables providing a syntax highlighter to the chat component.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {HighlighterExtension} syntaxHighlighter The syntax highlighter to be used.
     */
    withSyntaxHighlighter(syntaxHighlighter: HighlighterExtension): IAiChat;
    /**
     * Enables providing a theme to the chat component.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {string} themeId The id of the theme to be used.
     */
    withTheme(themeId: string): IAiChat;
}

declare class AiChat implements IAiChat {
    protected theAdapter: ChatAdapter | null;
    protected theAdapterBuilder: StandardChatAdapter | null;
    protected theAdapterType: 'builder' | 'instance' | null;
    protected theClassName: string | null;
    protected theConversationOptions: ConversationOptions | null;
    protected theInitialConversation: ConversationItem[] | null;
    protected theLayoutOptions: LayoutOptions | null;
    protected thePersonasOptions: PersonaOptions | null;
    protected thePromptBoxOptions: PromptBoxOptions | null;
    protected theSyntaxHighlighter: HighlighterExtension | null;
    protected theThemeId: string | null;
    private controller;
    private unregisteredEventListeners;
    get mounted(): boolean;
    hide(): void;
    mount(rootElement: HTMLElement): void;
    on(event: EventName, callback: EventsMap[EventName]): this;
    removeAllEventListeners(event?: EventName): void;
    removeEventListener(event: EventName, callback: EventCallback): void;
    show(): void;
    unmount(): void;
    updateProps(props: Partial<AiChatProps>): void;
    withAdapter(adapter: ChatAdapter | ChatAdapterBuilder): this;
    withClassName(className: string): this;
    withConversationOptions(conversationOptions: ConversationOptions): this;
    withInitialConversation(initialConversation: ConversationItem[]): this;
    withLayoutOptions(layoutOptions: LayoutOptions): this;
    withPersonaOptions(personaOptions: PersonaOptions): this;
    withPromptBoxOptions(promptBoxOptions: PromptBoxOptions): this;
    withSyntaxHighlighter(syntaxHighlighter: HighlighterExtension): this;
    withTheme(themeId: string): IAiChat;
}

interface IObserver<DataType> {
    complete?(): void;
    error?(error: Error): void;
    next(value: DataType): void;
}

type ObservableOperator = (observable: Observable<any>) => Observable<any>;
declare class Observable<DataType> {
    private buffer;
    private errorReceived;
    private isCompleted;
    private readonly isReplayObservable;
    private subscribers;
    constructor({ replay }?: {
        replay?: boolean;
    });
    complete(): void;
    error(error: Error): void;
    next(value: DataType): void;
    pipe(...operators: Array<ObservableOperator>): this;
    reset(): void;
    subscribe(observer: IObserver<DataType>): {
        unsubscribe: () => void;
    };
    unsubscribe(observer: IObserver<DataType>): void;
    private sendBufferToObserver;
}

type NluxRawError = {
    readonly message?: string;
    readonly type?: string;
    readonly source?: string;
    readonly exceptionId?: ExceptionId;
};
declare class NluxError extends Error {
    readonly exceptionId?: ExceptionId;
    readonly message: string;
    readonly source?: string;
    readonly type: string;
    constructor(rawError?: NluxRawError);
}
declare class NluxUsageError extends NluxError {
}
declare class NluxValidationError extends NluxError {
}
declare class NluxRenderingError extends NluxError {
}
declare class NluxConfigError extends NluxError {
}

type StreamParser = (root: HTMLElement, syntaxHighlighter?: HighlighterExtension) => IObserver<string>;
type StandardStreamParserOutput = IObserver<string> & {
    onComplete(completeCallback: Function): void;
};
type StandardStreamParser = (root: HTMLElement, syntaxHighlighter?: HighlighterExtension, options?: {
    openLinksInNewWindow?: boolean;
    skipAnimation?: boolean;
    streamingAnimationSpeed?: number;
    skipCopyToClipboardButton?: boolean;
}) => StandardStreamParserOutput;

declare const createMdStreamRenderer: StandardStreamParser;

declare const debug: (...messages: any[]) => void;

declare const warn: (message: any) => void;
declare const warnOnce: (message: string) => void;

declare const uid: () => string;

/**
 * This type represents the result of an assist request.
 *
 * If the request was successful, the `success` property will be `true` and the `response` property will contain the
 * text response to be displayed to the user. In addition, when the `task` property is present, it will contain the
 * details of the task to be executed by the client.
 *
 * If the request was not successful, the `success` property will be `false` and the `error` property will contain the
 * error message to be displayed to the user.
 */
type AssistResult = {
    success: true;
    response: string;
    task?: {
        id: string;
        parameters: string[];
    };
} | {
    success: false;
    error: string;
};
/**
 * This interface exposes methods that should be implemented by adapters used when the AiChat is in co-pilot mode.
 * The difference between this and the `ChatAdapter` interface is that this adapter can return a task to be executed
 * by the client in addition to the text response to be displayed.
 *
 * Assist adapters can only be used in fetch mode, and the response cannot be streamed.
 */
interface AssistAdapter {
    /**
     * This method should be implemented by any adapter that wants to request data from the API in fetch mode.
     * It should return a promise that resolves to the response from the API.
     * Either this method or `streamText` (or both) should be implemented by any adapter.
     *
     * @param `string` message
     * @param `ChatAdapterExtras` extras
     * @returns Promise<string>
     */
    assist?: (message: string, extras: ChatAdapterExtras) => Promise<AssistResult>;
}

/**
 * The base interface for creating a new instance of a StandardChatAdapter.
 * Adapter builders can extend this interface to add additional methods for configuration.
 */
interface AssistAdapterBuilder {
    /**
     * Create a new instance of an AssistAdapter.
     */
    create(): AssistAdapter;
}

type ContextItemDataType = number | string | boolean | null | ContextObject | ContextItemDataType[];
type ContextObject = {
    [key: string]: ContextItemDataType;
};
type ContextItem = {
    value: ContextItemDataType;
    description: string;
};
type ContextItems = Record<string, ContextItem>;
type ContextTask = {
    description: string;
    paramDescriptions: string[];
};
type ContextTasks = Record<string, ContextTask>;

type InitializeContextResult = {
    success: true;
    contextId: string;
} | {
    success: false;
    error: string;
};
type DestroyContextResult = {
    success: true;
} | {
    success: false;
    error: string;
};
type FlushContextResult = {
    success: true;
} | {
    success: false;
    error: string;
};
type RunTaskResult = {
    success: true;
    result?: any;
} | {
    success: false;
    error: string;
};
type ContextActionResult = {
    success: true;
} | {
    success: false;
    error: string;
};
type SetContextResult = {
    success: true;
    contextId: string;
} | {
    success: false;
    error: string;
};

/**
 * This represents a set of extra data that can be sent to the context adapter.
 * It can be used by implementations to send additional data such as authentication headers.
 */
type ContextAdapterExtras = {
    /**
     * This contains the headers that implementers can use to send additional data such as authentication headers.
     */
    headers?: Record<string, string>;
};

/**
 * The context data adapter is responsible for synchronizing the context data between the frontend application
 * and the backend system. In order to build a context-aware chat experience and AI assistants, the context
 * adapter should be used.
 *
 * nlux does not set any restrictions on the context data structure or where and how the data should be stored,
 * but it expects the backend system responsible for generating the chat responses to be able to access the
 * context data as needed.
 *
 * The goal of the context this adapter is to facilitate providing the context data to the backend.
 * The following methods are expected to be implemented by the context data adapter:
 *
 * - Set context data: On initial load, the context data should be set to the initial state.
 * - Get context data: Data loaded from the backend.
 * - Update context data: Called when the context data is updated.
 * - Clear context data: When the app is closed or the user logs out, the context data should be cleared.
 */
interface ContextDataAdapter {
    /**
     * Creates a new context and sets the initial context data when provided.
     * On success, the new context ID should be returned.
     *
     * @param {Object} initialData
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<SetContextResult>}
     */
    create: (initialItems?: ContextItems, extras?: ContextAdapterExtras) => Promise<SetContextResult>;
    /**
     * Deletes the context data and any registered tasks for the given context ID, and makes the context ID invalid.
     * This method should be used when the context is no longer needed.
     *
     * @param {string} contextId
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    discard: (contextId: string, extras?: ContextAdapterExtras) => Promise<ContextActionResult>;
    /**
     * Deletes the data for the given context ID and item IDs.
     *
     * @param {string} contextId The context ID.
     * @param {string[]} itemIds The item IDs to delete.
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    removeItems: (contextId: string, itemIds: string[], extras?: ContextAdapterExtras) => Promise<ContextActionResult>;
    /**
     * Resets the context data for the given context ID.
     * If no new context data is not provided, the context will be emptied.
     * If new context data is provided, it will replace the existing context data.
     *
     * @param {string} contextId
     * @param {ContextItems} newData
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    resetItems: (contextId: string, newData?: ContextItems, extras?: ContextAdapterExtras) => Promise<ContextActionResult>;
    /**
     * Updates data for the given context ID.
     *
     *
     * @param {string} contextId
     * @param {string} itemId
     * @param {Object} data
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    updateItems: (contextId: string, itemsToUpdate: Partial<ContextItems>, extras?: ContextAdapterExtras) => Promise<ContextActionResult>;
}

/**
 * The context tasks adapter is responsible for registering and unregistering tasks that can be triggered by
 * the AI assistant. The tasks are front-end specific but can be triggered by backend based on specific user
 * prompts in the AI chat. In order to build a context-aware chat experience that can also trigger front-end
 * tasks, the context tasks adapter should be used to let the backend know about the tasks that can be triggered.
 *
 * The following methods are expected to be implemented by the context tasks adapter:
 *
 * - Register task: When a new screen is loaded, or a specific state is reached, a new task can be registered.
 * - Unregister task: When the screen is closed or the state is no longer valid, the task should be unregistered.
 */
interface ContextTasksAdapter {
    /**
     * Unregisters specific tasks from the given context ID, based on their task IDs.
     *
     * @param {string} contextId
     * @param {string} taskIds[]
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    removeTasks: (contextId: string, taskIds: string[], extras?: ContextAdapterExtras) => Promise<ContextActionResult>;
    /**
     * Resets the tasks for the given context ID.
     * If new tasks are provided, they will replace the existing tasks.
     * If no tasks are provided, all the tasks will be emptied.
     *
     * @param {string} contextId
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    resetTasks: (contextId: string, newTasks?: ContextTasks, extras?: ContextAdapterExtras) => Promise<ContextActionResult>;
    /**
     * Updates the tasks included in the `tasks` object, for the given context ID.
     * Tasks that are not included in the `tasks` object should be left unchanged.
     * If you want to remove a task, you should use the `removeTasks` method.
     *
     * @param {string} contextId
     * @param {Partial<ContextTasks>} tasks
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    updateTasks: (contextId: string, tasks: Partial<ContextTasks>, extras?: ContextAdapterExtras) => Promise<ContextActionResult>;
}

/**
 * The context adapter context-aware chat experience and AI assistants.
 * This type provides the methods for both context data and tasks that should be implemented by adapters
 * in order to synchronize data related to the context between the frontend and the backend.
 *
 * If your chat experience does not require the execution of tasks, you can use the ContextDataAdapter type instead.
 * But if you need the LLM to execute tasks, as well as access the context data, you should use the ContextAdapter type
 * to implement both the context data and tasks.
 */
interface ContextAdapter extends ContextDataAdapter, ContextTasksAdapter {
}

/**
 * This represents the base interface for the context adapter builders.
 * The create method should be implemented to return a new instance of the context adapter.
 * Additional methods can be added to the builder to configure the context adapter via chaining.
 */
interface ContextAdapterBuilder {
    build(): ContextAdapter;
}

declare const predefinedContextSize: {
    '1k': number;
    '10k': number;
    '100k': number;
    '1mb': number;
    '10mb': number;
};
/**
 * Context data synchronization options.
 */
type DataSyncOptions = {
    /**
     * Data synchronization strategy.
     * - `auto` - Batch updates and automatically sync the context data.
     * - `lazy` - Only sync when the user is about to send a message.
     *
     * Default: `auto`
     */
    syncStrategy?: 'auto' | 'lazy';
    /**
     * The maximum size of the context data to be allowed and synced.
     * When the limit is reached, the oldest data will be removed.
     *
     * Default: `10kb`
     */
    contextSize?: number;
};

interface ContextDomElementHandler {
    destroy(): void;
}
/**
 * Once a context state item is registered, a state item handler with this interface will be created.
 * This handler will be used to update the state item's data and to destroy it when it is no longer needed.
 * It can also be used to change the description of the state item.
 */
interface ContextItemHandler {
    /**
     * Once the state item is no longer needed, it should be discarded. This method should be called to destroy the
     * state item. By doing so, the state item will be removed from the context and will no longer be used by the AI.
     */
    discard(): void;
    /**
     * This method is used to update the state item's data. The data is used by the AI to answer context-aware queries.
     * For example, if the user asks the AI about the logged-in user, the AI will use the data to provide the answer.
     * The data should be kept up-to-date to ensure that the AI provides accurate answers.
     *
     * @param {ContextItemDataType} data The new data to be used for the context state item.
     */
    setData(data: ContextItemDataType): void;
    /**
     * When a state item is registered, a description is provided.
     * That description is used by AI to determine how and it what context the state item is used.
     * For example, when the user queries the AI about a specific data in the page, the description will be used to
     * determine which context state items are relevant to the query, and thus it should always be up-to-date.
     *
     * This method can be used to change the description of the state item when the usage of the state item changes.
     * For example, the logged-in user in a marketplace app can be either a buyer or a seller, when they switch from
     * one role to another, the description of the state item should be updated to reflect the new role.
     *
     * @param {string} description
     */
    setDescription(description: string): void;
}
/**
 * Once a context task is registered, a task handler with this interface will be created.
 * This handler will be used to update the task's data, callback, and to destroy it when it is no longer needed.
 * It can also be used to change the description of the task and the descriptions of its parameters.
 */
interface ContextTaskHandler {
    discard(): void;
    setCallback(callback: Function): void;
    setDescription(description: string): void;
    setParamDescriptions(paramDescriptions: string[]): void;
}

/**
 * The current status of the context instance.
 * The default status is 'idle' and it changes to 'initializing' when the context is being initialized.
 * A context that is ready to be used has the status 'syncing' (i.e. the being synchronized with the backend).
 * If the context fails to initialize or synchronize, the status changes to 'error'.
 * The final status of a context is 'destroyed' after it has been destroyed.
 */
type AiContextStatus = 'idle' | 'initializing' | 'syncing' | 'error' | 'destroyed';
/**
 * The AiContext is responsible for managing data and tasks in the context of a user session.
 * This data and tasks can be used to provide a more personalized and relevant experience to the AI chatbot user.
 */
interface AiContext {
    /**
     * The unique identifier of the context instance.
     * This identifier is generated by the backend and assigned to the context instance when it is initialized.
     * This is only set once the context has been initialized. It will be null if the context has not been initialized.
     * When the context is destroyed, the context id will be set to null.
     *
     * @returns {string | null}
     */
    get contextId(): string | null;
    /**
     * Destroys the context instance and clears all data and tasks associated with it.
     * The context instance cannot be used after it has been destroyed.
     * If the destroy operation fails, the context instance is left in an error state.
     *
     * @returns {Promise<DestroyContextResult>}
     */
    destroy(): Promise<DestroyContextResult>;
    /**
     * Flushes the data synchronization queue.
     * This method will make an API call to the adapter to flush the data synchronization queue.
     * This can be done automatically by the data sync service (the frequency depends on the data sync strategy set),
     * but in situations where the data needs to be flushed immediately, this method can be called.
     *
     * @returns {Promise<FlushContextResult>}
     */
    flush(): Promise<FlushContextResult>;
    /**
     * Checks if the context is observing a state item with the provided itemId.
     *
     * @param {string} itemId
     * @returns {boolean}
     */
    hasItem(itemId: string): boolean;
    /**
     * Checks if the context has a task with the provided taskId that can be run.
     * Runnable tasks are tasks that have been registered with the backend and can be executed in the context.
     * When a registration fails, the task is not runnable.
     *
     * @param {string} taskId
     * @returns {boolean}
     */
    hasRunnableTask(taskId: string): boolean;
    /**
     * Checks if the context is observing a task with the provided taskId.
     *
     * @param {string} taskId
     * @returns {boolean}
     */
    hasTask(taskId: string): boolean;
    /**
     * Initializes the context instance and sets the initial data.
     * The context instance cannot be used before it has been initialized.
     * If the initialize operation fails, the context instance is left in an error state.
     * Initialization can only be done once for a context instance, when it's in the 'idle' state.
     *
     * @param {Object} data The optional initial data to set in the context instance.
     * @returns {Promise<InitializeContextResult>}
     */
    initialize(data?: ContextItems): Promise<InitializeContextResult>;
    /**
     * Observes a state item and updates the context when the state item's value changes.
     * This method returns a ContextItemHandler that can be used to update the state item's value.
     * If the context instance is destroyed or not properly initialized, the method will return undefined and will
     * log a warning. Users can use the status property to check the status of the context instance.
     *
     * The state item's description passed as a second argument is used by AI to determine how and it what context the
     * state item is used. When the user queries the AI about a specific data in the page, the description will be used
     * to determine which context state items are relevant to the query, and thus it should always be detailed and
     * accurate.
     *
     * @param {string} itemId The unique identifier of the state item to observe.
     * @param {string} description The description of the state item. The description is used to instruct the LLM on the
     *      how the state item is used and its role in the context. e.g. When the state item is 'logged-in-user', the
     *      description could be 'The logged-in user in the marketplace app. It can be used to provide a more
     *      personalized experience to the user.'
     *
     * @param {ContextItemDataType} initialData The initial data to set in the state item.
     *
     * @returns {ContextItemHandler | undefined} The state item handler that can be used to update the state item's
     *     value. If the context instance is destroyed or an item with the same itemId is already being observed, the
     *     method will return undefined and a warning will be logged.
     */
    observeState(itemId: string, description: string, initialData?: ContextItemDataType): ContextItemHandler | undefined;
    /**
     * Registers a task in the context instance.
     * A task is a function that can be executed in the context of the user session.
     *
     * @param {string} taskId The unique identifier of the task. If a task with the same identifier already exists,
     *    the registerTask method will return an error.
     * @param {string} description The description of the task. The description is used to instruct the LLM on the
     *  usefulness and role of the task. e.g. When the task is 'get-user-age', the description could be 'Get the age
     *  of the logged-in user from the user profile.'
     * @param {Function} callback The function to execute when the task runs.
     * @param {string[]} paramDescriptions The descriptions of the parameters that the task function expects. The
     *   parameter descriptions are very important because they instruct the LLM on how to retrieve the parameters' data
     *   from the context and how to use them in the task function. The parameter descriptions should be accurate and
     *   explicit. They should describe the role of the parameters in the callback function and how they can be
     *     retrieved. e.g. When the task function expects a parameter that represents the user's preferred language,
     *     the parameter description could be 'The preferred language of the logged-in user. It can be retrieved from
     *     the user profile.'
     *
     * @returns {ContextActionResult}
     */
    registerTask(taskId: string, description: string, callback: Function, paramDescriptions?: string[]): ContextTaskHandler | undefined;
    /**
     * Resets the context instance and sets the provided data. The contextId will not change after the reset operation
     * but all the context data and tasks will be cleared.
     * If the reset operation fails, the context instance is left in an error state.
     *
     * The reset operation clears all data and tasks associated with the context instance and sets the provided data.
     * It will also unregister all observers and tasks. You will need to re-register the tasks and re-observe the
     * elements and state items after the reset operation.
     *
     * @param {Object} data The optional data to set in the context instance.
     * @returns {Promise<ContextActionResult>}
     */
    reset(data?: ContextItems): Promise<ContextActionResult>;
    /**
     * Runs a task in the context instance.
     *
     * The task runner will attempt to retrieve the parameters from the context and execute the task function.
     * If the task function succeeds, the task runner will return the result of the task function under the 'result'
     * property of the returned object. If the task function fails, the task runner will return an error under the
     * 'error' property of the returned object.
     *
     * The status of the context instance will not change after running a task, regardless of the result of the task
     * function.
     *
     * @param {string} taskId The unique identifier of the task to run.
     * @param {Array<any>} parameters The parameters to pass to the task function.
     * @returns {Promise<RunTaskResult>}
     */
    runTask(taskId: string, parameters?: Array<any>): Promise<RunTaskResult>;
    /**
     * Get the status of the context.
     * The status will change as the context is being initialized, destroyed, or if an error occurs.
     *
     * - The initial status is 'idle'.
     * - The status will change to 'initializing' once the context is being initialized.
     * - The status will change to 'syncing' once the context has been initialized and is being synced.
     * - The status will change to 'error' if an error occurs.
     * - The status will change to 'destroyed' once the context has been destroyed.
     *
     * @returns {AiContextStatus}
     */
    get status(): AiContextStatus;
    /**
     * Sets the adapter to use for the context instance.
     * The adapter is responsible for synchronizing the context instance with the backend.
     * This method should be called before the context instance is initialized.
     * If the adapter is not set, the initialize method will fail.
     *
     * @param {ContextAdapterBuilder | ContextAdapter} adapter
     * @returns {AiContext}
     */
    withAdapter(adapter: ContextAdapterBuilder | ContextAdapter): AiContext;
    /**
     * Sets the options to use for data synchronization.
     * The options are used to configure the behavior of the data synchronization process.
     * This method should be called before the context instance is initialized.
     *
     * @param {DataSyncOptions} options
     * @returns {AiContext}
     */
    withDataSyncOptions(options: DataSyncOptions): AiContext;
}

declare const createAiContext: () => AiContext;

declare const createAiChat: () => AiChat;

export { type AdapterDecodeFunction, type AdapterEncodeFunction, AiChat, type AiChatInternalProps, type AiChatProps, type AiContext, type AiContextStatus, type AssistAdapter, type AssistAdapterBuilder, type AssistResult, type BotPersona, type ChatAdapter, type ChatAdapterBuilder, type ChatAdapterExtras, type ContextActionResult, type ContextAdapter, type ContextAdapterBuilder, type ContextAdapterExtras, type ContextDataAdapter, type ContextDomElementHandler, type ContextItem, type ContextItemDataType, type ContextItemHandler, type ContextItems, type ContextObject, type ContextTask, type ContextTaskHandler, type ContextTasks, type ContextTasksAdapter, type ConversationItem, type ConversationOptions, type CreateHighlighterOptions, type DataSyncOptions, type DataTransferMode, type DestroyContextResult, type ErrorCallback, type ErrorEventDetails, type EventCallback, type EventName, type EventsMap, type ExceptionId, type FlushContextResult, type Highlighter, type HighlighterColorMode, type HighlighterExtension, type IObserver, type InitializeContextResult, type InputFormat, type LayoutOptions, type MessageReceivedCallback, type MessageSentCallback, NluxConfigError, NluxError, NluxRenderingError, NluxUsageError, NluxValidationError, Observable, type OutputFormat, type ParticipantRole, type PersonaOptions, type PreDestroyCallback, type PreDestroyEventDetails, type PromptBoxOptions, type ReadyCallback, type ReadyEventDetails, type RunTaskResult, type SetContextResult, type StandardAdapterInfo, type StandardChatAdapter, type StandardStreamParser, type StandardStreamParserOutput, type StreamParser, type StreamingAdapterObserver, type UserPersona, createAiChat, createAiContext, createMdStreamRenderer, debug, predefinedContextSize, uid, warn, warnOnce };
